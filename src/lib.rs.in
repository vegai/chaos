use std::collections::HashMap;
use std::fs;
use std::io;
use std::fs::File;
use std::io::{Read, Write};
use std::os::unix::fs::PermissionsExt;
use std::process::exit;

#[derive(Serialize, Deserialize, Debug)]
pub struct Passwords {
    version: u8,
    pub metadata: HashMap<String, Password>,
}

#[derive(Serialize,Deserialize,Debug)]
pub struct Password {
    pub salt: String,
    pub format: u8,
    pub length: u16,
}

impl Default for Passwords {
    fn default() -> Passwords {
        Passwords {
            version: 1,
            metadata: HashMap::new(),
        }
    }
}

impl Passwords {
    pub fn title_exists(&self, title: &str) -> bool {
        self.metadata.contains_key(title)
    }

    pub fn insert(&mut self, title: &str, password: Password) {
        self.metadata.insert(title.to_string(), password);
    }
    pub fn load_from_file(path: &str) -> Passwords {
        match Passwords::load_file(path) {
            Ok(d) => serde_json::from_str(&d).ok().unwrap_or_default(), //(Passwords::default),
            Err(_) => Passwords::default(),
        }
    }
    pub fn load_file(path: &str) -> Result<String, io::Error> {
        let mut f = try!(File::open(path));
        let mut s = String::new();
        try!(f.read_to_string(&mut s));
        Ok(s)
    }

    pub fn save_data(data: &str, filename: &str) {
        let mut f = File::create(filename).unwrap();
        f.write_all(data.as_bytes()).expect("Data file write failed");
        f.write_all(b"\n").expect("Newline write failed!?");
        f.sync_all().expect("Sync failed");
    }

    pub fn set_file_perms(filename: &str, mode: u32) {
        let mut perms = fs::metadata(filename).expect("Gettings perms failed").permissions();
        perms.set_mode(mode);
        fs::set_permissions(filename, perms).expect("Setting permission failed");
    }

    pub fn to_string_pretty(&self) -> String {
        serde_json::to_string_pretty(self).unwrap()
    }

    pub fn find_by_title_or_bail<'a>(&'a self, title: &str) -> &'a Password {
        match self.metadata.get(title) {
            Some(password) => password,
            None => {
                println!("'{}' does not exist.", title);
                exit(2);
            }
        }
    }

}



