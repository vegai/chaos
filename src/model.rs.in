use std::collections::HashMap;
use std::process::exit;

use super::common;

#[derive(Serialize, Deserialize, Debug)]
pub struct Passwords {
    version: u8,
    pub metadata: HashMap<String, Password>,
}

#[derive(Serialize,Deserialize,Debug)]
pub struct Password {
    pub salt: String,
    pub format: u8,
    pub length: u16,
}

impl Default for Passwords {
    fn default() -> Passwords {
        Passwords {
            version: 1,
            metadata: HashMap::new(),
        }
    }
}

impl Passwords {
    pub fn title_exists(&self, title: &str) -> bool {
        self.metadata.contains_key(title)
    }

    pub fn insert(&mut self, title: &str, password: Password) {
        self.metadata.insert(title.to_string(), password);
    }

    pub fn load_from_file(path: &str) -> Passwords {
        match common::load_file(path) {
            Ok(d) => serde_json::from_str(&d).ok().unwrap_or_default(), //(Passwords::default),
            Err(_) => Passwords::default(),
        }
    }

    pub fn to_string_pretty(&self) -> String {
        serde_json::to_string_pretty(self).unwrap()
    }

    pub fn find_by_title_or_bail<'a>(&'a self, title: &str) -> &'a Password {
        match self.metadata.get(title) {
            Some(password) => password,
            None => {
                println!("'{}' does not exist.", title);
                exit(2);
            }
        }
    }
}

