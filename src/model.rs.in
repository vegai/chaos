use std::collections::HashMap;
use std::process::exit;
use super::common;


// not used until I know how to work with Serde
#[derive(Serialize, Deserialize, Debug)]
pub enum FormatChoice {
    AlphaNumAndSymbols,
    AlphaNum,
    AlphaOnly,
    NumOnly,
    BinaryOnlyLol
}

impl Default for FormatChoice {
    fn default() -> FormatChoice {
        FormatChoice::AlphaNumAndSymbols
    }
}

impl FormatChoice {
    pub fn get_from_parameter(param: &str) -> FormatChoice {
        match param {
            _ => {
                println!("Uknown param {}!", param);
                FormatChoice::BinaryOnlyLol
            }
        }
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Passwords {
    version: u8,
    pub metadata: HashMap<String, Password>
}

impl Default for Passwords {
    fn default() -> Passwords {
        Passwords {
            version: 1,
            metadata: HashMap::new(),
        }
    }
}


impl Passwords {
    pub fn title_exists(&self, title: &str) -> bool {
        self.metadata.contains_key(title)
    }

    pub fn insert(&mut self, title: &str, password: Password) {
        self.metadata.insert(title.to_string(), password);
    }

    pub fn load_from_file(path: &str) -> Passwords {
        match common::load_file(path) {
            Ok(d) => serde_json::from_str(&d).ok().unwrap_or_default(), //(Passwords::default),
            Err(_) => Passwords::default(),
        }
    }

    pub fn to_string_pretty(&self) -> String {
        serde_json::to_string_pretty(self).unwrap()
    }

    pub fn find_by_title_or_bail<'a>(&'a self, title: &str) -> &'a Password {
        match self.metadata.get(title) {
            Some(password) => password,
            None => {
                println!("'{}' does not exist.", title);
                exit(2);
            }
        }
    }
}

#[derive(Serialize,Deserialize,Debug)]
pub struct Password {
    pub salt: String,
    pub meat: String,
    pub text: String,
    pub format: FormatChoice,
    pub length: u16,
}

impl Default for Password {
    fn default() -> Password {
        Password {
            salt: "".to_string(),
            meat: "".to_string(),
            text: "".to_string(),
            length: 32,
            format: FormatChoice::default(),
        }
    }
}

impl Password {
    fn new_for_test(format: FormatChoice, length: u16) -> Password {
        Password {
            salt: "".to_string(),
            meat: "".to_string(),
            text: "".to_string(),
            length: length,
            format: format
        }
    }
    fn pack_into_password(&self, hash: &[u8]) -> String {
        match self.format {
            FormatChoice::AlphaNumAndSymbols => {
                pack("!\"#$%&'()*+,-./0123456789:;\
                      <=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
                     hash)
            }
            FormatChoice::AlphaNum => {
                pack("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
                     hash)
            }
            FormatChoice::AlphaOnly => pack("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", hash),
            FormatChoice::NumOnly => pack("0123456789", hash),
            FormatChoice::BinaryOnlyLol => pack("01", hash)
        }
    }

    pub fn cut(&self, pass: Vec<u8>) -> String {
        let packed_pass = self.pack_into_password(&*pass);
        packed_pass.chars().take(self.length as usize).collect()
    }
}

fn pack(allowed_chars: &str, hash: &[u8]) -> String {
    let source_len = allowed_chars.len();
    let mut output = String::new();
    for &byte in hash {
        let n = (byte % source_len as u8) as usize;
        output.push(allowed_chars.chars().nth(n).unwrap());
    }
    output
}


#[test]
fn test_cut_binary_password() {
    let pass = vec!(1, 1, 88, 240, 120, 150, 13, 21, 34, 55);
    let password = Password::new_for_test(FormatChoice::BinaryOnlyLol, 8);
    assert_eq!("11000011", password.cut(pass.clone()));


    let password = Password::new_for_test(FormatChoice::BinaryOnlyLol, 6);
    assert_eq!("110000", password.cut(pass.clone()));
}

#[test]
fn test_cut_numeral_password() {
    let pass = vec!(1, 1, 88, 240, 120, 150, 13, 21, 34, 55);
    let password = Password::new_for_test(FormatChoice::NumOnly, 8);
    assert_eq!("11800031", password.cut(pass.clone()));

    let password = Password::new_for_test(FormatChoice::NumOnly, 6);
    assert_eq!("118000", password.cut(pass.clone()));
}

#[test]
fn test_cut_alphaonly_password() {
    let pass = vec!(1, 1, 88, 240, 120, 150, 13, 21, 34, 55);
    let password = Password::new_for_test(FormatChoice::AlphaOnly, 8);
    assert_eq!("bbKGqUnv", password.cut(pass.clone()));

    let password = Password::new_for_test(FormatChoice::AlphaOnly, 6);
    assert_eq!("bbKGqU", password.cut(pass.clone()));
}

#[test]
fn test_cut_alphanum_password() {
    let pass = vec!(1, 1, 88, 240, 120, 150, 13, 21, 34, 55);
    let password = Password::new_for_test(FormatChoice::AlphaNum, 8);
    assert_eq!("bbA26Anv", password.cut(pass.clone()));

    let password = Password::new_for_test(FormatChoice::AlphaNum, 6);
    assert_eq!("bbA26A", password.cut(pass.clone()));
}

#[test]
fn test_cut_alphanumsym_password() {
    let pass = vec!(1, 1, 88, 240, 120, 150, 13, 21, 34, 55);
    let password = Password::new_for_test(FormatChoice::AlphaNumAndSymbols, 8);
    assert_eq!("\"\"yU;Y.6", password.cut(pass.clone()));

    let password = Password::new_for_test(FormatChoice::AlphaNumAndSymbols, 6);
    assert_eq!("\"\"yU;Y", password.cut(pass.clone()));
}
